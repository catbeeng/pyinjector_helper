import { assert } from "console";
import { PyClass } from "../PyClass";
import { PyImport } from "../PyImport";
import { ExtensionClassNameConfig, ExtensionFileNameConfig } from "../../../services/configLoader";
import { generateImports } from "../../../services/importsGenerator";
import { formatMultiLineArgs, INDENT_UNIT_AMOUNT } from "../../../services/multiLineArgsFormatter";

export class ModuleGenerator {

    public constructor(
        public readonly pyClass: PyClass,
        public readonly dependenciesImports: PyImport[],
        public readonly interfaceName: string | null,
        public readonly targetImport: PyImport,
        public readonly interfaceImport: PyImport | null,
        private readonly fileNameConfig: ExtensionFileNameConfig,
        private readonly classNameConfig: ExtensionClassNameConfig,
    ) { }

    public generateSource(): string {
        const className = this.pyClass.name;
        const dependencyImports = this.generateDependencyImports();
        const parameters = this.generateParameters();
        const parametersWithType = this.generateParametersWithType();
        const targetInterface = this.interfaceName ?? className;

        return `# generated by pyinjector-helper
from injector import provider, singleton, Module
${dependencyImports}


class ${this.moduleClassName}(Module):
    @singleton
    @provider
    def provide(${parametersWithType}) -> ${targetInterface}:
        return ${className}(${parameters})
`;
    } // end generateSource

    public get moduleFileName(): string {
        const targetInterface = this.existInterfaceImport;
        const interfaceName = targetInterface.module.split(".").at(-1) as string;
        assert(interfaceName !== undefined);
        let name = interfaceName;
        this.fileNameConfig.remove.forEach(p => name = name.replace(new RegExp(p), ""));
        return this.fileNameConfig.addPrefix + `${name}` + this.fileNameConfig.addSuffix;
    }

    private get moduleClassName(): string {
        if (this.classNameConfig.deriveFromFileName) {
            return this.moduleFileName.replace(/(^|_)([a-z])/g, (_, __, c) => c.toUpperCase());
        }
        const className = this.pyClass.name;
        let name = this.interfaceName ?? className;
        this.classNameConfig.remove.forEach(p => name = name.replace(new RegExp(p), ""));
        return this.classNameConfig.addPrefix + `${name}` + this.classNameConfig.addSuffix;
    }

    get existInterfaceImport(): PyImport {
        return this.interfaceImport ?? this.targetImport;
    }

    private generateDependencyImports(): string {
        const imports = [...this.dependenciesImports, this.targetImport];
        if (this.interfaceImport) {
            imports.push(this.interfaceImport);
        }
        return generateImports(imports);
    }

    private generateParametersWithType(): string {
        const args = this.pyClass.getConstructorArgs();
        if (args.length === 0) { return "self"; }
        const argLines = ["self", ...args.map(arg =>
            arg.annotation ? `${arg.name}: ${arg.annotation}` : arg.name
        )];
        return formatMultiLineArgs(argLines, INDENT_UNIT_AMOUNT * 2);
    }

    private generateParameters(): string {
        const args = this.pyClass.getConstructorArgs();
        if (args.length === 0) { return ""; }
        const argLines = args.map(arg => arg.name);
        return formatMultiLineArgs(argLines, INDENT_UNIT_AMOUNT * 3);
    }
}
