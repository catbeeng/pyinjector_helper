import { assert } from "console";
import { PyClass } from "../PyClass";
import { PyImport } from "../PyImport";

const INDENT_UNIT_AMOUNT = 4;

export class ModuleGenerator {

    public constructor(
        public readonly pyClass: PyClass,
        public readonly dependenciesImports: PyImport[],
        public readonly interfaceName: string | null,
        public readonly targetImport: PyImport,
        public readonly interfaceImport: PyImport | null
    ) { }

    public get existInterfaceImport(): PyImport {
        return this.interfaceImport ?? this.targetImport;
    }

    public generateSource(): string {
        const className = this.pyClass.name;
        const dependencyImports = this.generateDependencyImports();
        const parameters = this.generateParameters();
        const parametersWithType = this.generateParametersWithType();
        const targetInterface = this.interfaceName ?? className;
        const moduleName = (targetInterface).replace(/Interface$/, '');

        return `// generated by pyinjector-helper
from injector import provider, singleton, Module
${dependencyImports}


class ${moduleName}Module(Module):
    @singleton
    @provider
    def provide(${parametersWithType}) -> ${targetInterface}:
        return ${className}(${parameters})
`;
    } // generateSource

    public getModuleFileName(): string {
        const targetInterface = this.interfaceImport ?? this.targetImport;
        const interfaceName = targetInterface.module.split(".").at(-1) as string;
        assert(interfaceName !== undefined);
        const name = interfaceName.replace(/^interface_/, '')
            .replace(/_interface$/, '');
        return `${name}_module`;
    }

    private generateDependencyImports(): string {
        const imports = [...this.dependenciesImports, this.targetImport];
        if (this.interfaceImport) {
            imports.push(this.interfaceImport);
        }
        imports.sort((a, b) => a.module.localeCompare(b.module));
        const lines = imports.flatMap((imp) => {
            const names = imp.names.map(
                (n) => n.asname ? `${n.name} as ${n.asname}` : n.name
            ).join(", ");
            return `from ${imp.module} import ${names}`;
        });
        return lines.join("\n");
    }

    private generateParametersWithType(): string {
        const args = this.pyClass.getConstructorArgs();
        if (args.length === 0) { return "self"; }
        const argLines = ["self", ...args.map(arg =>
            arg.annotation ? `${arg.name}: ${arg.annotation}` : arg.name
        )];
        return this.formatMultilineArgs(argLines, INDENT_UNIT_AMOUNT * 2);
    }

    private generateParameters(): string {
        const args = this.pyClass.getConstructorArgs();
        if (args.length === 0) { return ""; }
        const argLines = args.map(arg => arg.name);
        return this.formatMultilineArgs(argLines, INDENT_UNIT_AMOUNT * 3);
    }

    private formatMultilineArgs(lines: string[], indentWidth: number): string {
        if (lines.length === 1) { return lines[0]; }
        const indent = ' '.repeat(indentWidth);
        const lastIndent = ' '.repeat(indentWidth - INDENT_UNIT_AMOUNT);
        return "\n" + lines.
            map((line) => indent + line + ",").
            join("\n") + "\n" + lastIndent;
    }

}
