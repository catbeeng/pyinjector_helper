import { assert } from "console";
import { PyClass } from "../PyClass";
import { PyImport } from "../PyImport";
import { ExtensionClassNameConfig, ExtensionFileNameConfig } from "../../../services/configLoader";

const INDENT_UNIT_AMOUNT = 4;

export class ModuleGenerator {

    public constructor(
        public readonly pyClass: PyClass,
        public readonly dependenciesImports: PyImport[],
        public readonly interfaceName: string | null,
        public readonly targetImport: PyImport,
        public readonly interfaceImport: PyImport | null,
        private readonly fileNameConfig: ExtensionFileNameConfig,
        private readonly classNameConfig: ExtensionClassNameConfig,
    ) { }

    public generateSource(): string {
        const className = this.pyClass.name;
        const dependencyImports = this.generateDependencyImports();
        const parameters = this.generateParameters();
        const parametersWithType = this.generateParametersWithType();
        const targetInterface = this.interfaceName ?? className;

        return `# generated by pyinjector-helper
from injector import provider, singleton, Module
${dependencyImports}


class ${this.moduleClassName}(Module):
    @singleton
    @provider
    def provide(${parametersWithType}) -> ${targetInterface}:
        return ${className}(${parameters})
`;
    } // end generateSource

    public get moduleFileName(): string {
        const targetInterface = this.existInterfaceImport;
        const interfaceName = targetInterface.module.split(".").at(-1) as string;
        assert(interfaceName !== undefined);
        let name = interfaceName;
        this.fileNameConfig.remove.forEach(p => name = name.replace(new RegExp(p), ""));
        return this.fileNameConfig.addPrefix + `${name}` + this.fileNameConfig.addSuffix;
    }

    private get moduleClassName(): string {
        if (this.classNameConfig.deriveFromFileName) {
            return this.moduleFileName.replace(/(^|_)([a-z])/g, (_, __, c) => c.toUpperCase());
        }
        const className = this.pyClass.name;
        let name = this.interfaceName ?? className;
        this.classNameConfig.remove.forEach(p => name = name.replace(new RegExp(p), ""));
        return this.classNameConfig.addPrefix + `${name}` + this.classNameConfig.addSuffix;
    }

    get existInterfaceImport(): PyImport {
        return this.interfaceImport ?? this.targetImport;
    }

    private generateDependencyImports(): string {
        const imports = [...this.dependenciesImports, this.targetImport];
        if (this.interfaceImport) {
            imports.push(this.interfaceImport);
        }
        imports.sort((a, b) => a.module.localeCompare(b.module));
        const lines = imports.flatMap((imp) => {
            const names = imp.names.map(
                (n) => n.asname ? `${n.name} as ${n.asname}` : n.name
            ).join(", ");
            return `from ${imp.module} import ${names}`;
        });
        return lines.join("\n");
    }

    private generateParametersWithType(): string {
        const args = this.pyClass.getConstructorArgs();
        if (args.length === 0) { return "self"; }
        const argLines = ["self", ...args.map(arg =>
            arg.annotation ? `${arg.name}: ${arg.annotation}` : arg.name
        )];
        return this.formatMultilineArgs(argLines, INDENT_UNIT_AMOUNT * 2);
    }

    private generateParameters(): string {
        const args = this.pyClass.getConstructorArgs();
        if (args.length === 0) { return ""; }
        const argLines = args.map(arg => arg.name);
        return this.formatMultilineArgs(argLines, INDENT_UNIT_AMOUNT * 3);
    }

    private formatMultilineArgs(lines: string[], indentWidth: number): string {
        if (lines.length === 1) { return lines[0]; }
        const indent = ' '.repeat(indentWidth);
        const lastIndent = ' '.repeat(indentWidth - INDENT_UNIT_AMOUNT);
        return "\n" + lines.
            map((line) => indent + line + ",").
            join("\n") + "\n" + lastIndent;
    }

}
